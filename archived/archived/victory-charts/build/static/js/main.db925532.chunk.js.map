{"version":3,"sources":["charts/BaseChart.tsx","charts/AreaChart.tsx","charts/BarChart.tsx","charts/LineChart.tsx","charts/PieBaseChart.tsx","charts/DonutChart.tsx","charts/PieChart.tsx","charts/StackChart.tsx","charts/UtilizationDonut.tsx","charts/ChartContainer.tsx","charts/PropsValidation.tsx","App.tsx","serviceWorker.ts","index.tsx","charts/XYChart.tsx"],"names":["BaseChart","props","legendOrientation","legendData","animationProp","containerComponent","labels","datum","name","y","constrainToVisibleArea","buildLegendData","legendPosition","zoom","animation","enabled","duration","easing","this","categories","map","React","Component","AreaChart","ChartGroup","dataSetToXYData","line","seriesLines","lineData","i","ChartArea","key","data","interpolation","d","yVal","XYChart","BarChart","offset","ChartBar","LineChart","ChartLine","PieBaseChart","dataSet","length","push","ds","rows","series","currentPos","DonutChart","width","height","theme","ChartDonut","ariaDesc","ariaDescription","ariaTitle","dataSetToPieChart","pieLegendPosition","padding","animate","subTitle","donutSubTitle","title","donutTitle","themeColor","PieChart","ChartPie","StackChart","ChartStack","labelComponent","ChartTooltip","UtilizationDonut","ChartDonutUtilization","buildData","x","columns","DEFAULT_DATASET","type","settings","columnName","valueExpression","valuePattern","ChartContainer","containerRef","handleResize","selectChart","receiveEvent","createRef","state","validation","isValid","bottom","left","right","top","grid","current","clientWidth","setState","event","params","properties","get","chartType","n","required","message","notEnoughColumns","validateDataSetForChart","paddingBottom","paddingRight","paddingLeft","paddingTop","gridx","gridy","window","addEventListener","removeEventListener","ref","style","App","className","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","numeral","require","domainPadding","showGrid","dependentAxis","tickFormat","t","format","pattern","buildChartGroup","slice","column","getPattern","Object","values","toString","replace","groupedLines","Map","cols","getcolumnExpression","getcolumn1Expression","getExpression","expression","exp","forEach","set","j","cat","eval","lines","value"],"mappings":"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","file":"static/js/main.db925532.chunk.js","sourcesContent":["import React from 'react';\nimport { PaddingProps, AnimationEasing, AnimatePropTypeInterface } from 'victory-core';\nimport { VictoryZoomContainer } from 'victory-zoom-container';\nimport { ChartVoronoiContainer } from '@patternfly/react-charts';\n\nexport type ThemeType = \"blue\" | \"cyan\" | \"blue\" | \"gold\" | \"gray\" |\n    \"green\" | \"multi\" | \"multi-ordered\" | \"multi-unordered\" |\n    \"orange\" | \"purple\";\n\n\nexport type LegendPosition = \"bottom-left\" | \"bottom\" | \"right\";\nexport type ChartType = \"bar\" | \"area\" | \"line\" | \"donut\" | \"pie\" | \"stack\" | \"utilization-donut\";\nexport type LegendOrientation = \"horizontal\" | \"vertical\";\nexport type ColumnType = \"TEXT\" | \"LABEL\" | \"DATE\" | \"NUMBER\";\n\nexport interface XYChartData {\n    x: any;\n    y: number;\n}\n\nexport interface ChartSeries {\n    name: string;\n}\n\nexport interface XYChartDataLine extends XYChartData, ChartSeries {\n}\n\nexport interface XYChartSeries extends ChartSeries {\n    data: XYChartData[];\n}\n\nexport interface PieChartSerie extends ChartSeries {\n    y: number;\n}\n\nexport interface Column {\n    name: string;\n    type: ColumnType;\n    settings: Object;\n}\n\nexport interface DataSet {\n    columns: Column[];\n    data: string[][];\n}\n\nexport interface Grid {\n    x: boolean;\n    y: boolean;\n}\n\nexport interface AnimationProp {\n    enabled: boolean;\n    duration?: number;\n    easing?: AnimationEasing;\n}\n\nexport interface LegendData {\n    name: string;\n}\n\nexport interface ChartProps {\n    width: number;\n    height: number;\n    theme: ThemeType;\n    zoom: boolean;\n    dataSet: DataSet;\n    legendPosition: LegendPosition;\n    animation: AnimationProp;\n    ariaTitle: string;\n    ariaDescription: string;\n    grid: Grid;\n    padding: PaddingProps;\n\n    donutTitle?: string;\n    donutSubTitle?: string;\n}\n\nexport abstract class BaseChart extends React.Component<ChartProps, any> {\n\n    legendOrientation: LegendOrientation = \"horizontal\";\n    legendData: LegendData[] = [];\n    animationProp: boolean | AnimatePropTypeInterface = false;\n    containerComponent: React.ReactElement<any> = <ChartVoronoiContainer\n        labels={({ datum }) => `${datum.name}: ${datum.y}`}\n        constrainToVisibleArea />;\n\n    constructor(props) {\n        super(props);\n        this.buildLegendData();\n        this.legendOrientation = this.props.legendPosition === 'right' ? 'vertical' : 'horizontal';\n        if (props.zoom) {\n            this.containerComponent = <VictoryZoomContainer />;\n        }\n        if (props.animation.enabled) {\n            this.animationProp = {\n                duration: props.animation.duration,\n                easing: props.animation.easing\n            };\n        }\n    }\n\n\n    buildLegendData() {\n        this.legendData = this.categories().map(name => {\n            return { name: name };\n        });\n    }\n\n    abstract categories(): string[];\n\n}\n","import React from 'react';\n\nimport { ChartArea, ChartGroup } from '@patternfly/react-charts';\nimport '@patternfly/patternfly/patternfly-charts.css'; // Required for mix-blend-mode CSS property\nimport { XYChart } from './XYChart';\n\nexport class AreaChart extends XYChart {\n\n  buildChartGroup(): any {\n    return (\n      <ChartGroup>\n        {this.dataSetToXYData()\n          .map(line => this.seriesLines(line))\n          .map((lineData, i) => <ChartArea key={i} data={lineData} interpolation=\"monotoneX\" y = {(d) => d.yVal} />)}\n      </ChartGroup>\n    );\n  }\n}","import React from \"react\";\n\nimport { ChartBar, ChartGroup } from \"@patternfly/react-charts\";\nimport { XYChart } from \"./XYChart\";\n\nexport class BarChart extends XYChart {\n  buildChartGroup(): any {\n    return (\n      <ChartGroup offset={10}>\n        {this.dataSetToXYData()\n          .map(line => {\n            return this.seriesLines(line)\n          })\n          .map((lineData, i) => {\n            return<ChartBar key={i} data={lineData} y = {(d) => d.yVal} />\n          }     \n          )}\n      </ChartGroup>\n    )\n  }\n}\n","import React from 'react';\n\nimport { ChartGroup, ChartLine } from '@patternfly/react-charts';\nimport { XYChart } from './XYChart';\n\nexport class LineChart extends XYChart {\n\n  buildChartGroup(): any {\n    return (\n      <ChartGroup>\n        {this.dataSetToXYData()\n          .map(line => this.seriesLines(line))\n          .map((lineData, i) =>\n            <ChartLine key={i} data={lineData} y = {(d) => d.yVal} />\n          )}\n      </ChartGroup>\n    );\n  }\n}","import { BaseChart, PieChartSerie } from './BaseChart';\n\nexport type PieLegendPositionType = \"bottom\" | \"right\";\n\nexport abstract class PieBaseChart extends BaseChart {\n\n    categories(): string[] {\n        const data = this.props.dataSet.data;\n        const categories: string[] = [];\n        for (let i = 0; i < data.length; i++) {\n            categories.push(data[i][0]);\n        }\n        return categories;\n    }\n\n    dataSetToPieChart(): PieChartSerie[] {\n        const ds = this.props.dataSet;\n        const rows = this.props.dataSet.data.length;\n        const series: PieChartSerie[] = [];\n\n        for (let i = 0; i < rows; i++) {\n            series.push({\n                name: ds.data[i][0],\n                y: +ds.data[i][1]\n            });\n        }\n        return series;\n    }\n\n    pieLegendPosition(): PieLegendPositionType {\n        const currentPos = this.props.legendPosition;\n        if (currentPos === \"bottom\" || currentPos) {\n            return currentPos as PieLegendPositionType;\n        }\n\n        return \"right\";\n    }\n}","import React from 'react';\n\nimport { ChartDonut } from '@patternfly/react-charts';\nimport { PieBaseChart } from './PieBaseChart';\n\nexport class DonutChart extends PieBaseChart {\n\n  render() {\n    const { width, height, theme } = this.props;\n    return (\n      <ChartDonut\n        ariaDesc={this.props.ariaDescription}\n        ariaTitle={this.props.ariaTitle}\n        constrainToVisibleArea={true}\n        data={this.dataSetToPieChart()}\n        labels={({ datum }) => `${datum.name}: ${datum.y}`}\n        legendData={this.legendData}\n        legendOrientation={this.legendOrientation}\n        legendPosition={this.pieLegendPosition()}\n        padding={this.props.padding}\n        animate={this.animationProp}\n        subTitle={this.props.donutSubTitle || \"\"}\n        title={this.props.donutTitle || \"\"}\n        themeColor={theme}\n        width={width}\n        height={height}\n      />\n    );\n  }\n}","import React from 'react';\n\nimport { ChartPie } from '@patternfly/react-charts';\nimport '@patternfly/patternfly/patternfly-charts.css'; // Required for mix-blend-mode CSS property\nimport { BaseChart } from './BaseChart';\nimport { PieBaseChart } from './PieBaseChart';\n\nexport class PieChart extends PieBaseChart {\n\n  render() {\n    const { width, height, theme } = this.props;\n    return (\n      <ChartPie\n        ariaDesc={this.props.ariaDescription}\n        ariaTitle={this.props.ariaTitle}\n        constrainToVisibleArea={true}\n        data={this.dataSetToPieChart()}\n        height={height}\n        labels={({ datum }) => `${datum.name}: ${datum.y}`}\n        legendData={this.legendData}\n        legendOrientation={this.legendOrientation}\n        legendPosition={this.pieLegendPosition()}\n        animate={this.animationProp}\n        padding={this.props.padding}\n        themeColor={theme}\n        width={width}\n      />\n    );\n  }\n}","import React from 'react';\n\nimport { ChartBar, ChartStack, ChartTooltip } from '@patternfly/react-charts';\nimport '@patternfly/patternfly/patternfly-charts.css'; // Required for mix-blend-mode CSS property\nimport { XYChart } from './XYChart';\n\nexport class StackChart extends XYChart {\n\n  buildChartGroup(): any {\n    return (\n      <ChartStack>\n        {this.dataSetToXYData()\n          .map(line => this.seriesLines(line))\n          .map((lineData, i) => <ChartBar key={i} data={lineData} labelComponent={<ChartTooltip constrainToVisibleArea />} y = {(d) => d.yVal} />)}\n      </ChartStack>\n    );\n  }\n}","import React from 'react';\nimport { PieBaseChart } from './PieBaseChart';\nimport { ChartDonutUtilization } from '@patternfly/react-charts';\n\nexport class UtilizationDonut extends PieBaseChart {\n\n    render() {\n        return (\n            <ChartDonutUtilization\n                ariaDesc={this.props.ariaDescription}\n                ariaTitle={this.props.ariaTitle}\n                constrainToVisibleArea={true}\n                themeColor={this.props.theme}\n                data={this.buildData()}\n                labels={({ datum }) => datum.x ? `${datum.x}: ${datum.y}%` : null}\n                subTitle={this.props.donutSubTitle || \"Utilization\"}\n                title={this.props.donutTitle || \"Total\"}\n                width={this.props.width}\n                height={this.props.height}\n                padding={this.props.padding}\n                legendData={this.buildLegendData()}\n                legendOrientation={this.legendOrientation}\n                legendPosition={this.pieLegendPosition()}\n            />\n        );\n    }\n\n    buildLegendData() {\n        const ds = this.props.dataSet;\n        const legendName = `${ds.columns[0].name}: ${ds.data[0][0]}%`;\n        return [{\n            name: legendName\n        }];\n\n    }\n    buildData() {\n        const ds = this.props.dataSet;\n        return {\n            x: ds.columns[0].name,\n            y: +ds.data[0][0]\n        };\n    }\n\n}","import React from \"react\";\nimport { AreaChart } from \"./AreaChart\";\nimport { BarChart } from \"./BarChart\";\nimport { LineChart } from \"./LineChart\";\nimport { DonutChart } from \"./DonutChart\";\nimport { PieChart } from \"./PieChart\";\nimport { StackChart } from \"./StackChart\";\nimport { PaddingProps, AnimationEasing } from \"victory-core\";\nimport {\n  ThemeType,\n  DataSet,\n  ChartType,\n  LegendPosition,\n  Grid,\n  AnimationProp,\n} from \"./BaseChart\";\nimport { ValidationResult, validateDataSetForChart } from \"./PropsValidation\";\nimport { UtilizationDonut } from \"./UtilizationDonut\";\n\ninterface Props {}\n\ninterface Params {\n  chartType: ChartType;\n  theme: ThemeType;\n}\n\nconst DEFAULT_DATASET: DataSet = {\n  columns: [\n    { name: \"Animal\", type: \"TEXT\", settings: { columnName: \"New\", valueExpression: \"value\", valuePattern: \"value\" } },\n    { name: \"2017\", type: \"NUMBER\", settings: { columnName: \"New\", valueExpression: \"value\", valuePattern: \"value\" } },\n    { name: \"2018\", type: \"NUMBER\", settings: { columnName: \"New\", valueExpression: \"value\", valuePattern: \"value\" } },\n    { name: \"2019\", type: \"NUMBER\", settings: { columnName: \"New\", valueExpression: \"value\", valuePattern: \"value\" } },\n    { name: \"2020\", type: \"NUMBER\", settings: { columnName: \"New\", valueExpression: \"value\", valuePattern: \"value\"} },\n  ],\n  data: [\n    [\"Pigs\", \"3\", \"7\", \"2\", \"9\"],\n    [\"Dogs\", \"6\", \"3\", \"2\", \"7\"],\n    [\"Sheeps\", \"5\", \"1\", \"2\", \"1\"],\n    [\"Horses\", \"6\", \"2\", \"2\", \"3\"],\n    [\"Cows\", \"1\", \"2\", \"4\", \"8\"],\n    [\"Cats\", \"1\", \"2\", \"2\", \"4\"],\n  ],\n};\n\ninterface State {\n  width: number;\n  height: number;\n  type: ChartType;\n  theme: ThemeType;\n  validation: ValidationResult;\n  dataSet: DataSet;\n  legendPosition: LegendPosition;\n  animation: AnimationProp;\n  ariaTitle: string;\n  ariaDescription: string;\n  padding: PaddingProps;\n  zoom: boolean;\n  grid: Grid;\n  donutTitle?: string;\n  donutSubTitle?: string;\n}\n\nexport class ChartContainer extends React.Component<Props, State> {\n  containerRef: React.RefObject<any>;\n  handleResize: () => void;\n  selectChart: (type: ChartType) => JSX.Element;\n  receiveEvent: (event: any) => void;\n\n  constructor(props: Props) {\n    super(props);\n    this.containerRef = React.createRef();\n    this.state = {\n      width: 600,\n      height: 300,\n      type: \"stack\",\n      theme: \"multi-ordered\",\n      validation: { isValid: true },\n      dataSet: DEFAULT_DATASET,\n      legendPosition: \"bottom\",\n      animation: {\n        enabled: false,\n      },\n      ariaTitle: \"Chart Title\",\n      ariaDescription: \"Chart Description\",\n      zoom: false,\n      padding: { bottom: 20, left: 0, right: 0, top: 0 },\n      grid: { x: true, y: false },\n    };\n\n    this.handleResize = () => {\n      if (this.containerRef.current && this.containerRef.current.clientWidth) {\n        this.setState({ width: this.containerRef.current.clientWidth });\n      }\n    };\n\n    this.receiveEvent = (event: any) => {\n      const params = event.data.properties as Map<string, object>;\n      const dataSet = params.get(\"dataSet\") as DataSet;\n      const chartType = (params.get(\"chartType\") as unknown) as ChartType;\n      const validation = validateDataSetForChart(chartType, dataSet);\n\n      const paddingBottom = params.get(\"paddingBottom\") || \"0\";\n      const paddingRight = params.get(\"paddingRight\") || \"0\";\n      const paddingLeft = params.get(\"paddingLeft\") || \"0\";\n      const paddingTop = params.get(\"paddingTop\") || \"0\";\n\n      const gridx = (params.get(\"gridx\") as unknown) === \"true\";\n      const gridy = (params.get(\"gridy\") as unknown) === \"true\";\n\n      const animation = (params.get(\"animate\") as unknown) == \"true\";\n      const animationProp: AnimationProp = {\n        enabled: animation,\n      };\n      if (animation) {\n        animationProp.duration = +(params.get(\"animationDuration\") || \"0\");\n        animationProp.easing = (params.get(\"animationEasing\") ||\n          \"linear\") as AnimationEasing;\n      }\n\n      const grid: Grid = {\n        x: gridx,\n        y: gridy,\n      };\n\n      const padding: PaddingProps = {\n        bottom: +paddingBottom,\n        right: +paddingRight,\n        left: +paddingLeft,\n        top: +paddingTop,\n      };\n\n      this.setState({\n        type:\n          ((params.get(\"chartType\") as unknown) as ChartType) ||\n          this.state.type,\n        theme:\n          ((params.get(\"theme\") as unknown) as ThemeType) || this.state.theme,\n        dataSet:\n          ((params.get(\"dataSet\") as unknown) as DataSet) || this.state.dataSet,\n        legendPosition:\n          ((params.get(\"legendPosition\") as unknown) as LegendPosition) ||\n          this.state.legendPosition,\n        animation: animationProp,\n        ariaTitle: (params.get(\"ariaTitle\") as unknown) as string,\n        ariaDescription: (params.get(\"ariaDescription\") as unknown) as string,\n        padding: padding,\n        zoom: (params.get(\"zoom\") as unknown) === \"true\",\n        grid: grid,\n        validation: validation,\n        donutTitle: params.get(\"donutTitle\") as any,\n        donutSubTitle: params.get(\"donutSubTitle\") as any,\n      });\n    };\n\n    this.selectChart = (type: ChartType) => {\n      switch (type) {\n        case \"area\":\n          return <AreaChart {...this.state} />;\n        case \"bar\":\n          return <BarChart {...this.state} />;\n        case \"line\":\n          return <LineChart {...this.state} />;\n        case \"donut\":\n          return <DonutChart {...this.state} />;\n        case \"pie\":\n          return <PieChart {...this.state} />;\n        case \"stack\":\n          return <StackChart {...this.state} />;\n        case \"utilization-donut\":\n          return <UtilizationDonut {...this.state} />;\n      }\n    };\n  }\n\n  componentDidMount() {\n    this.handleResize();\n    window.addEventListener(\"resize\", this.handleResize);\n    window.addEventListener(\"message\", this.receiveEvent, false);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener(\"resize\", this.handleResize);\n    window.removeEventListener(\"message\", this.receiveEvent, false);\n  }\n\n  render() {\n    const { type, validation } = this.state;\n    return (\n      <div ref={this.containerRef} style={{ width: \"auto\", height: \"auto\" }}>\n        {validation.isValid ? (\n          this.selectChart(type)\n        ) : (\n          <em>{validation.message}</em>\n        )}\n      </div>\n    );\n  }\n}\n","import { ChartType, ColumnType, Column, DataSet } from './BaseChart';\n\nexport interface ValidationResult {\n    isValid: boolean;\n    message?: string;\n}\n\nconst FIRST_COLUMN_TYPES: ColumnType[] = [\"TEXT\", \"LABEL\", \"DATE\"];\nconst SERIES_COLUMN_TYPE: ColumnType = \"NUMBER\";\n\nconst notEnoughColumns = (chartType: string, n: number, required: number): ValidationResult => {\n    return {\n        isValid: false,\n        message: `Not enough columns to build chart of type ${chartType}. The dataset has ${n}, but the chart requires at least ${required}`\n    }\n}\n\nconst wrongSeriesType = (chartType: ChartType): ValidationResult => {\n    return {\n        isValid: false,\n        message: `Series data type for ${chartType} must be ${SERIES_COLUMN_TYPE}`\n    }\n}\n\nconst notAllColumnsofType = (columns: Column[], startIndex: number, columnType: ColumnType) =>\n    columns.slice(startIndex).some(c => c.type !== columnType);\n\n\nexport function validateDataSetForChart(chartType: ChartType, dataSet: DataSet): ValidationResult {\n    const columns = dataSet.columns;\n    /*\n    switch (chartType) {\n        case \"area\" || \"bar\" || \"line\" || \"stack\":\n            if (notAllColumnsofType(columns, 2, SERIES_COLUMN_TYPE)) {\n                return wrongSeriesType(chartType);\n            }\n            break;\n        case \"donut\" || \"pie\":\n            if (notAllColumnsofType(columns, 1, SERIES_COLUMN_TYPE)) {\n                return wrongSeriesType(chartType);\n            }\n            break;\n    }\n    */\n\n    if (columns.length < 2 && chartType != \"utilization-donut\") {\n        return notEnoughColumns(chartType, columns.length, 2);\n    }\n    /*\n        if (!FIRST_COLUMN_TYPES.some(t => t === columns[0].type)) {\n            return {\n                isValid: false,\n                message: `First Column for ${chartType} should have one of the following types: ${FIRST_COLUMN_TYPES}`\n            };\n        }\n    */\n    return { isValid: true };\n};","import React from 'react';\n\nimport './App.css';\nimport { ChartContainer } from './charts/ChartContainer';\n\nfunction App() {\n\n  return (\n    <div className=\"App\">\n      <ChartContainer />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import React from \"react\";\nimport {\n  BaseChart,\n  XYChartSeries,\n  XYChartDataLine,\n  XYChartData,\n} from \"./BaseChart\";\nimport { Chart, ChartAxis, ChartGroup } from \"@patternfly/react-charts\";\nvar numeral = require(\"numeral\");\n\nexport type ChartGroupType = typeof ChartGroup;\n\nexport abstract class XYChart extends BaseChart {\n  render() {\n    const { width, height, theme } = this.props;\n    return (\n      <Chart\n        ariaDesc={this.props.ariaDescription}\n        ariaTitle={this.props.ariaTitle}\n        containerComponent={this.containerComponent}\n        domainPadding={{ x: [30, 25] }}\n        legendData={this.legendData}\n        legendOrientation={this.legendOrientation}\n        legendPosition={this.props.legendPosition}\n        height={height}\n        animate={this.animationProp}\n        padding={this.props.padding}\n        themeColor={theme}\n        width={width}\n      >\n        <ChartAxis showGrid={this.props.grid.y} />\n        <ChartAxis dependentAxis showGrid={this.props.grid.x}\n          tickFormat={(t) => numeral(t).format(this.pattern())} />\n        {this.buildChartGroup()}\n      </Chart>\n    );\n  }\n\n  abstract buildChartGroup(): ChartGroupType;\n\n  categories() {\n    return this.props.dataSet.columns\n      .slice(1)\n      .map((column) => column.settings[\"columnName\"]);\n  }\n\n  pattern(){\n    let getPattern = this.props.dataSet.columns\n    .slice(1)\n    .map((column) => column.settings[\"valuePattern\"]);\n    let pattern = Object.values(getPattern)[0].toString();\n    let p = pattern.replace(/#/g, \"0\");\n    return p;\n  }\n\n  dataSetToXYData(): XYChartSeries[] {\n    let groupedLines: Map<string, XYChartData[]> = new Map();\n    const categories = this.categories();\n    const ds = this.props.dataSet;\n    const rows = ds.data.length;\n    const cols = ds.columns.length;\n    let getcolumnExpression = this.props.dataSet.columns\n      .slice(0)\n      .map((column) => column.settings[\"valueExpression\"]);\n    let getcolumn1Expression = Object.values(getcolumnExpression)[0].toString();\n    let getExpression = this.props.dataSet.columns\n      .slice(1)\n      .map((column) => column.settings[\"valueExpression\"]);\n    let expression = Object.values(getExpression)[0].toString();\n    let exp = expression.replace(\"value\", \"1\");\n    const series: XYChartSeries[] = [];\n\n    categories.forEach((name) => groupedLines.set(name, []));\n\n    for (let i = 0; i < rows; i++) {\n      const name = ds.data[i][0];\n      for (let j = 1; j < cols; j++) {\n        const cat = categories[j - 1];\n        groupedLines.get(cat)?.push({\n          x: eval(getcolumn1Expression.replace(\"value\",'\"' + name + '\"')),\n          y: numeral(+ds.data[i][j] * eval(exp)).format(this.pattern()),\n        });\n      }\n    }\n    groupedLines.forEach((lines, name) =>\n      series.push({ name: name, data: lines })\n    );\n    return series;\n  }\n\n  seriesLines(series: XYChartSeries): XYChartDataLine[] {\n    return series.data.map((d) => {\n      return { name: series.name, x: d.x, y: d.y, yVal: numeral(d.y).value() };\n    });\n  }\n}\n"],"sourceRoot":""}